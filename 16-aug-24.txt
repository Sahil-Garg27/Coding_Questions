//  Coding Question

Question1: Strings Rotations of Each Other

You are given two strings of equal lengths, s1 and s2. The task is to check if s2 is a rotated version of the string s1.

Note: The characters in the strings are in lowercase.

Question Link: https://www.geeksforgeeks.org/problems/check-if-strings-are-rotations-of-each-other-or-not-1587115620/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=practice_card

Approach: In this Question first i have check that both string are qual or not. Then i concatenate the s1 string two times and then i am checking that if s2 appears as a substring within rotated.

Code: 


class Solution
{
    //Function to check if two strings are rotations of each other or not.
    public static boolean areRotations(String s1, String s2 )
    {
        // Your code here
        
        //return (s1.length() == s2.length()) && (s1 + s1).contains(s2);

        if(s1.length() != s2.length()){
            return false;
        }
        
        String rotated = s1+s1;
        int count = 0;
        int j = 0;
        
        for(int i = 0; i < rotated.length(); i++){
            if(j == s2.length()){
                break;
            }
            if(rotated.charAt(i) == s2.charAt(j)){
                count++;
                j++;
            }
            if(count == s2.length()){
                return true;
            }
        }
        return false;
    }
    
}



Question 2: Longest Palindrome in a String
Given a string str, find the longest palindromic substring in str. Substring of string str: str[ i . . . . j ] where 0 ≤ i ≤ j < len(str). Return the longest palindromic substring of str.

Palindrome string: A string that reads the same backward. More formally, str is a palindrome if reverse(str) = str. In case of conflict, return the substring which occurs first ( with the least starting index).

Question Link: https://www.geeksforgeeks.org/problems/longest-palindrome-in-a-string3411/1

Approach: I have started the loop through each character in the string S,  to check each character as the potential to the center of a palindrome.  finds the longest palindromic substring by expanding around each character and each pair of consecutive characters as potential centers. It checks for both odd and even length palindromes, updating the longest found if a longer one is identified. After exploring all potential centers, it returns the longest palindrome substring.

Code: 

//User function Template for Java
class Solution{
    static String longestPalin(String S){
        // code here
        String res = "";
        for(int i = 0; i < S.length(); i++){
            int l = i;
            int r = i;
            while(l >= 0 && r < S.length() && S.charAt(l) == S.charAt(r)){
                l--;
                r++;
            }
            String pal = S.substring(l+1, r);
            if(pal.length() > res.length()) res = pal;
            
            l = i;
            r = i+1;
            
            while(l >= 0 && r < S.length() && S.charAt(l) == S.charAt(r)){
                l--;
                r++;
            }
            pal = S.substring(l+1, r);
            if(pal.length() > res.length()) res = pal;
        }
        return res;
    }
}



Question3:Next Permutation
Implement the next permutation, which rearranges the list of numbers into Lexicographically next greater permutation of list of numbers. If such arrangement is not possible, it must be rearranged to the lowest possible order i.e. sorted in an ascending order. You are given an list of numbers arr[ ] of size N.

Question Link: https://www.geeksforgeeks.org/problems/next-permutation5226/1|

Approach: This approach is to find the next permutation involves first identifying the rightmost index where the array elements are in increasing order. If no such index exists, the array is sorted in ascending order as it represents the last permutation. Otherwise, the algorithm swaps the element at this index with the smallest larger element to its right, then sorts the remaining elements to the right of the index to get the next permutation.

Code: 

// User function Template for Java

class Solution{
    static List<Integer> nextPermutation(int n, int arr[]){
        // Step1 find the break point
        List<Integer> ans = new ArrayList<>();
        int ind = -1;
        for(int i = n-2; i >= 0; i--){
            if(arr[i] < arr[i+1]){
                ind = i;
                break;
            }
        }
        
        // if ind == -1 in that case we just have o simply reverse the array and resture
        if(ind == -1){
            Arrays.sort(arr);
            for(int val : arr) ans.add(val);
            return ans;
        }
        
        // now we i will find next greater then element and then i will swap them
        for(int i = n-1; i > ind; i--){
            if(arr[i] > arr[ind]){
                int temp = arr[i];
                arr[i] = arr[ind];
                arr[ind] = temp;
                break;
            }
        }
        
        Arrays.sort(arr, ind+1, n);
        for(int val : arr) ans.add(val);
        return ans;
    }
}

Question 4: Split the binary string into substrings with equal number of 0s and 1s
Given binary string str of length N. The task is to find the maximum count of consecutive substrings str can be divided into such that all the substrings are balanced i.e. they have an equal number of 0s and 1s. If it is not possible to split str satisfying the conditions then return -1.

Question Link: https://www.geeksforgeeks.org/problems/split-the-binary-string-into-substrings-with-equal-number-of-0s-and-1s/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=practice_card

Approach: In this question first i checked whether the length is even or not, and then i took three variables ONE for counts 1's and ZERO for counts 0's and ans to return the ans; then I iterated over the string whenever the one and zero val become equal to in that case i increase the count and in the end i am checking that if zero and one value is != 0 it means zero and one are not equal in that case i simply return the otherwise ans

Code: //User function Template for Java

class Solution {
    public static int maxSubStr(String str) {
       //Write your code here
       if(str.length()%2 != 0) return -1;
       int ans =0; int zero = 0; int one = 0;
       for(int i = 0; i < str.length(); i++){
           char ch = str.charAt(i);
           if(ch == '0') zero++;
           if(ch == '1') one++;
           if(zero == one){
               ans++;
               zero = 0;
               one = 0;
           }
       }
       if(ans == 0 || zero != 0 || one != 0) return -1;
       return ans;
    }
}