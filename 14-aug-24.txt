// Coding Questions

Question1 Link: https://www.geeksforgeeks.org/problems/spirally-traversing-a-matrix-1587115621/1

Question 1 : Spirally traversing a matrix

Question: You are given a rectangular matrix, and your task is to return an array while traversing the matrix in spiral form.

Approach: 1.Initialize boundaries (left, right, top, down) and iterate while the list size is less than the total number of elements.
2. Traverse the matrix from left to right, then from top to bottom, followed by right to left, and finally from bottom to top, adjusting boundaries after each traversal.
3. Update the boundaries after each traversal and add elements to the result list until all elements are visited.

Code:   // Function to return a list of integers denoting spiral traversal of matrix.
    public ArrayList<Integer> spirallyTraverse(int matrix[][]) {
        // code here
        int m = matrix.length;
        int n = matrix[0].length;
        int left = 0, right = n-1, top = 0, down = m-1;
        int matrixSize =m * n;
        ArrayList<Integer> ans = new ArrayList<Integer>();
        
        while(ans.size() != matrixSize){
            
            // first i am traversing from left to right
            for(int i = left; i <= right && matrixSize > ans.size(); i++){
                ans.add(matrix[top][i]);
            }
            top++;
            
            // now i am traversing from top to botton
            for(int i = top; i <= down && matrixSize > ans.size(); i++){
                ans.add(matrix[i][right]);
            }
            right--;
            
            // here we will travese from right to left
            for(int i = right; i >= left && matrixSize > ans.size(); i--){
                ans.add(matrix[down][i]);
            }
            down--;
            
            // from down to top
            for(int i = down; i >= top && matrixSize > ans.size(); i--){
                ans.add(matrix[i][left]);
            }
            left++;
        }
        return ans;
    }
Time Complexity: O(N*N);
Space Complexity: O(N);

Question2 Link: https://www.geeksforgeeks.org/problems/row-with-max-1s0023/1

Question2: Row with max 1s

You are given a 2D array consisting of only 1's and 0's, where each row is sorted in non-decreasing order. You need to find and return the index of the first row that has the most number of 1s. If no such row exists, return -1.
Note: 0-based indexing is followed.

Approach: Initialize indices and traverse each row using two pointers (j and k) to efficiently count the number of 1s by checking from both ends.
Update the count of 1s in each row and compare it with the maximum count found so far.
Track and return the row index that has the highest count of 1s.

Code:     public int rowWithMax1s(int arr[][]) {
        // code here
        int index = -1;
        int max = 0;
        int n = arr[0].length;
        
        for(int i = 0; i < arr.length; i++){
            int j = 0, k = n-1;
            while(j <= k){
                if(arr[i][j] == 1 && arr[i][k] == 1) break;
                else if(arr[i][j] != 1 && arr[i][k] != 1){
                    j++;
                    k--;
                }else if(arr[i][j] == 1 && arr[i][k] != 1){
                    k--;
                }else{
                    j++;
                }
            }
            int totalOnes = k - j + 1;
            if(totalOnes > max){
                index = i;
                max = totalOnes;
            }
        }
        return index;
    }

Time Complexity: O(m*n)
Space Complexity: O(1)


Question3 link: https://www.geeksforgeeks.org/problems/rotate-by-90-degree-1587115621/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=practice_card

Question 3: Rotate by 90 degree
Given a square matrix of size N x N. The task is to rotate it by 90 degrees in anti-clockwise direction without using any extra space. 

Approach:Reverse Each Row: Swap elements within each row from the start and end towards the center to reverse the rows horizontally.
Transpose the Matrix: Swap elements across the main diagonal to convert rows into columns.

    static void rotateby90(int matrix[][], int n) 
    { 
        // reverse
         for (int i = 0; i <=n-1; i++) {
            for (int j = 0; j <=(n/2)-1; j++) {
              /*  System.out.println(mat[i][j]);
                System.out.println(mat[i][n-1-j]);*/
                int temp = matrix[i][n-1-j];
                matrix[i][n-1-j] = matrix[i][j];
                matrix[i][j] = temp;
            }
        }
       // transpose

        for (int i = 0; i <=n-1; i++) {
            for (int j = 0; j <=n-1; j++) {

                if(i!=j && i<j){
                    int temp = matrix[i][j];
                    matrix[i][j] = matrix[j][i];
                    matrix[j][i] = temp;
                }
            }
        }
    
    }   

Time Complexity: O(n2)


Question4 Link: https://leetcode.com/problems/reverse-string/

Question 4: Reverse String
Write a function that reverses a string. The input string is given as an array of characters s.

You must do this by modifying the input array in-place with O(1) extra memory.

Use two pointers starting from the beginning and end of the array, swapping elements until they meet in the middle.
Increment the starting pointer and decrement the ending pointer after each swap until the entire array is reversed.

    public void reverseString(char[] s) {
        if(s.length == 1 || s.length == 0) return;
        int i = 0; int j = s.length - 1;
        while(i < j){
            char temp = s[i];
            s[i] = s[j];
            s[j] = temp;
            i++;
            j--;
        }
        return;
    }

Time Complexity: O(N)
Space Complexity: O(1)