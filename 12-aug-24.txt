Coding Question//
Question Link: https://www.geeksforgeeks.org/problems/minimize-the-heights3351/1
Question1: Minimize the Heights II
Given an array arr[] denoting heights of N towers and a positive integer K.

For each tower, you must perform exactly one of the following operations exactly once.

Increase the height of the tower by K
Decrease the height of the tower by K
Find out the minimum possible difference between the height of the shortest and tallest towers after you have modified each tower.

You can find a slight modification of the problem here.
Note: It is compulsory to increase or decrease the height by K for each tower. After the operation, the resultant array should not contain any negative integers.

Approach: First I sort the array. and Initialise the smallest and largest values by adjusting the smallest and largest elements of the sorted array with k. Iterate through the sorted array, updating the minimum and maximum values considering each element adjusted by k. Finally, compute and return the smallest difference between the updated maximum and minimum values.

int getMinDiff(int[] arr, int n, int k) {
        // code here
        if(n == 1) return 0;
        Arrays.sort(arr);
        int ans = arr[n-1] - arr[0];
        int smallest = arr[0] + k;
        int largest = arr[n-1] - k;
        int min = 0; int max = 0;
        for(int i = 0; i < n-1; i++){
            min = Math.min(smallest, arr[i+1] - k);
            max = Math.max(largest, arr[i] + k);
            if(min < 0) continue;
            ans  = Math.min(ans, max - min);
        }
        return ans;
    }

Time complexity: O(N);
Space complexity: O(1);


Question Link: https://www.geeksforgeeks.org/problems/merge-two-sorted-arrays-1587115620/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=practice_card

Question2 : Merge Without Extra Space
Given two sorted arrays arr1[] and arr2[] of sizes n and m in non-decreasing order. Merge them in sorted order without using any extra space. Modify arr1 so that it contains the first N elements and modify arr2 so that it contains the last M elements.

Approach: Started by comparing arr1 from the end and arr2 from starting. While comparing if I found the array2 value is small then I swap with the arr1. If the arr1 val is not small and equal to it means it already sorted so I break the function. And then before return i sort the whole arrays

 public static void merge(long arr1[], long arr2[], int n, int m) 
    {
        // code here 
        if(n == 0) return;
        if(m == 0) return;
        int i = n-1, j = 0, k = m;
        while(i >= 0 && j < m){
            if(arr1[i] > arr2[j]){
                long temp = arr1[i];
                arr1[i] = arr2[j];
                arr2[j] = temp;
                i--;
                j++;
            }else{
             break;   
            }
        }
        Arrays.sort(arr1);
        Arrays.sort(arr2);
        return;
    }

    Time complexity = O(small array) + 2(nlogn);
    Space complexity = O(1);