Coding Question//
Question Link: https://www.geeksforgeeks.org/problems/minimize-the-heights3351/1
Question1: Minimize the Heights II
Given an array arr[] denoting heights of N towers and a positive integer K.

For each tower, you must perform exactly one of the following operations exactly once.

Increase the height of the tower by K
Decrease the height of the tower by K
Find out the minimum possible difference between the height of the shortest and tallest towers after you have modified each tower.

You can find a slight modification of the problem here.
Note: It is compulsory to increase or decrease the height by K for each tower. After the operation, the resultant array should not contain any negative integers.

Approach: First I sort the array. and Initialise the smallest and largest values by adjusting the smallest and largest elements of the sorted array with k. Iterate through the sorted array, updating the minimum and maximum values considering each element adjusted by k. Finally, compute and return the smallest difference between the updated maximum and minimum values.

Code : 

int getMinDiff(int[] arr, int n, int k) {
        // code here
        if(n == 1) return 0;
        Arrays.sort(arr);
        int ans = arr[n-1] - arr[0];
        int smallest = arr[0] + k;
        int largest = arr[n-1] - k;
        int min = 0; int max = 0;
        for(int i = 0; i < n-1; i++){
            min = Math.min(smallest, arr[i+1] - k);
            max = Math.max(largest, arr[i] + k);
            if(min < 0) continue;
            ans  = Math.min(ans, max - min);
        }
        return ans;
    }

Time complexity: O(N);
Space complexity: O(1);

#########################

Question Link: https://www.geeksforgeeks.org/problems/merge-two-sorted-arrays-1587115620/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=practice_card

Question2 : Merge Without Extra Space
Given two sorted arrays arr1[] and arr2[] of sizes n and m in non-decreasing order. Merge them in sorted order without using any extra space. Modify arr1 so that it contains the first N elements and modify arr2 so that it contains the last M elements.

Approach: Started by comparing arr1 from the end and arr2 from starting. While comparing if I found the array2 value is small then I swap with the arr1. If the arr1 val is not small and equal to it means it already sorted so I break the function. And then before return i sort the whole arrays

Code: 

 public static void merge(long arr1[], long arr2[], int n, int m) 
    {
        // code here 
        if(n == 0) return;
        if(m == 0) return;
        int i = n-1, j = 0, k = m;
        while(i >= 0 && j < m){
            if(arr1[i] > arr2[j]){
                long temp = arr1[i];
                arr1[i] = arr2[j];
                arr2[j] = temp;
                i--;
                j++;
            }else{
             break;   
            }
        }
        Arrays.sort(arr1);
        Arrays.sort(arr2);
        return;
    }

    Time complexity = O(small array) + 2(nlogn);
    Space complexity = O(1);

#############################

Question Link: https://www.geeksforgeeks.org/problems/common-elements1132/1

Question 3: Common in 3 Sorted Arrays
You are given three arrays sorted in increasing order. Find the elements that are common in all three arrays.
If there are no such elements return an empty array. In this case, the output will be -1.

Note: can you handle the duplicates without using any additional Data Structure?

Approach : Here I am using a three-pointer approach on three arrays. Iterate through the lists with three pointers (i, j, and k) to compare elements. Add to the result array if all three-pointers' elements are equal and skip over the duplicates. 

Code: 
 public List<Integer> commonElements(List<Integer> arr1, List<Integer> arr2,
                                        List<Integer> arr3) {
        // Code Here
     List<Integer> ans = new ArrayList<>();
        int m = arr1.size(), n = arr2.size(), o = arr3.size();
        int i = 0, j = 0, k = 0;
        
        while (i < m && j < n && k < o) {
            int val1 = arr1.get(i);
            int val2 = arr2.get(j);
            int val3 = arr3.get(k);
            
            if (val1 == val2 && val2 == val3) {
                // common element add in a array
                ans.add(val1);
                // here i am moving allpointers to remove duplicates 
                while (i < m && arr1.get(i).equals(val1)) i++;
                while (j < n && arr2.get(j).equals(val2)) j++;
                while (k < o && arr3.get(k).equals(val3)) k++;
            } else if (val1 < val2) {
                // if the val is small just simpling moving the pointer ahead
                i++;
            } else if (val2 < val3) {
                // if the val is small just simply moving the pointer ahead
                j++;
            } else {
                k++;
            }
        }
        
        return ans;
    }

    Time complexity: O(n1 + n2 + n3);
    Space Complexity = O(1);

###############################

Question Link: https://www.geeksforgeeks.org/problems/inversion-of-array-1587115620/1

Question 4 : Count Inversions

Given an array of integers. Find the Inversion Count in the array.  Two array elements arr[i] and arr[j] form an inversion if arr[i] > arr[j] and i < j.

Inversion Count: For an array, inversion count indicates how far (or close) the array is from being sorted. If the array is already sorted then the inversion count is 0.
If an array is sorted in the reverse order then the inversion count is the maximum. 

Approach: First, I am using the function that merges two sorted halves while counting how many times elements from the right half are less than elements from the left half. The merge sort function recursively divides the array and counts the inversion.

Code: 
static long count = 0;
    // arr[]: Input Array
    // N : Size of the Array arr[]
    // Function to count inversions in the array.
static long merge(long[] arr,int low,int mid,int high){
        List<Long> list=new ArrayList<>();
        int left=low;
        int right=mid+1;
        long cnt=0;
        while(left<=mid && right<=high){
            if(arr[left]<=arr[right]){
                list.add(arr[left]);
                left++;
            }else{
                list.add(arr[right]);
                cnt+=mid-left+1;
                right++;
            }
        }
        while(left<=mid){
            list.add(arr[left]);
            left++;
        }
        while(right<=high){
            list.add(arr[right]);
            right++;
        }
        for(int i=low;i<=high;i++){
            arr[i]=list.get(i-low);
        }
        return cnt;
    }
    static long mergeSort(long[] arr,int low,int high){
        long cnt=0;
        if(low>=high){
            return cnt;
        }
        // while(low<=high){
            int mid=(low+high)/2;
            cnt+=mergeSort(arr,low,mid);
            cnt+=mergeSort(arr,mid+1,high);
            cnt+=merge(arr,low,mid,high);
        // }
        return cnt;
    }
    static long inversionCount(long arr[], int n) {
       return mergeSort(arr,0,n-1);
    }

    Time Complexity: O(nlogn)
    Space Complexity: O(n+m);